//! Simple Game Client
//!
//! An interactive client that connects to the SpacetimeDB module and
//! allows you to query and explore the loaded Tiled map data.

// Import the generated module bindings
// These are generated by: spacetime generate --lang rust --out-dir src/module_bindings --project-path ../server
mod module_bindings;

use module_bindings::{
    tiled_layer_table::TiledLayerTableAccess,
    tiled_map_table::TiledMapTableAccess,
    tiled_object_table::TiledObjectTableAccess,
    tiled_property_table::TiledPropertyTableAccess,
    tiled_tile_table::TiledTileTableAccess,
    tiled_tileset_table::TiledTilesetTableAccess,
    DbConnection,
};
use spacetimedb_sdk::{DbContext, Table};
use std::io::{self, Write};
use std::time::Duration;

const HOST: &str = "http://localhost:3000";
const DB_NAME: &str = "simple-game";

fn main() {
    println!("=== Simple Game Client ===");
    println!("Connecting to SpacetimeDB at {}...\n", HOST);

    // Connect to the database
    let conn = connect_to_db();

    println!("Subscribing to map data...");

    // Subscribe to all Tiled tables
    subscribe_to_tables(&conn);

    // Start the event loop in a background thread
    // This is required for the SDK to process messages and apply subscriptions
    conn.run_threaded();

    // Give the subscription a moment to be applied
    std::thread::sleep(Duration::from_millis(500));

    println!("\nType 'help' for available commands.\n");

    // Run the interactive command loop
    command_loop(&conn);
}

/// Connect to the SpacetimeDB instance
fn connect_to_db() -> DbConnection {
    // Build the connection
    DbConnection::builder()
        .with_uri(HOST)
        .with_module_name(DB_NAME)
        .on_connect(|_conn, _identity, _token| {
            println!("✓ Connection established");
        })
        .on_connect_error(|_conn, error| {
            eprintln!("✗ Connection error: {}", error);
            std::process::exit(1);
        })
        .on_disconnect(|_conn, _error| {
            println!("Disconnected from server");
        })
        .build()
        .expect("Failed to build connection")
}

/// Subscribe to all Tiled tables
fn subscribe_to_tables(conn: &DbConnection) {
    conn.subscription_builder()
        .on_applied(on_sub_applied)
        .on_error(on_sub_error)
        .subscribe([
            "SELECT * FROM tiled_map",
            "SELECT * FROM tiled_layer",
            "SELECT * FROM tiled_tile",
            "SELECT * FROM tiled_tileset",
            "SELECT * FROM tiled_object",
            "SELECT * FROM tiled_property",
        ]);
}

/// Called when subscriptions are successfully applied
fn on_sub_applied(ctx: &module_bindings::SubscriptionEventContext) {
    let map_count = ctx.db.tiled_map().iter().count();
    let layer_count = ctx.db.tiled_layer().iter().count();
    let tile_count = ctx.db.tiled_tile().iter().count();
    let object_count = ctx.db.tiled_object().iter().count();

    println!("✓ Subscriptions applied");
    println!("  Loaded: {} maps, {} layers, {} tiles, {} objects",
        map_count, layer_count, tile_count, object_count);
}

/// Called when subscription fails
fn on_sub_error(_ctx: &module_bindings::ErrorContext, err: spacetimedb_sdk::Error) {
    eprintln!("✗ Subscription error: {}", err);
    std::process::exit(1);
}

/// Main command loop
fn command_loop(conn: &DbConnection) {
    let stdin = io::stdin();
    let mut input = String::new();

    loop {
        // Print prompt
        print!("> ");
        io::stdout().flush().unwrap();

        // Read input
        input.clear();
        stdin.read_line(&mut input).expect("Failed to read line");
        let line = input.trim();

        // Skip empty lines
        if line.is_empty() {
            continue;
        }

        // Parse and execute command
        let parts: Vec<&str> = line.split_whitespace().collect();
        if parts.is_empty() {
            continue;
        }

        match parts[0] {
            "help" | "h" | "?" => show_help(),
            "quit" | "exit" | "q" => break,
            "list" => handle_list(conn, &parts[1..]),
            "tile" => handle_tile(conn, &parts[1..]),
            "objects" => handle_objects(conn, &parts[1..]),
            "spawns" => handle_spawns(conn),
            "map" => handle_map_info(conn, &parts[1..]),
            "layers" => handle_layers(conn, &parts[1..]),
            "props" => handle_properties(conn, &parts[1..]),
            "walkable" => handle_walkable(conn, &parts[1..]),
            _ => println!(
                "Unknown command: '{}'. Type 'help' for available commands.",
                parts[0]
            ),
        }
    }

    println!("\nGoodbye!");
}

/// Show help message
fn show_help() {
    println!("\nAvailable Commands:");
    println!("  help                     - Show this help message");
    println!("  list maps                - List all loaded maps");
    println!("  list layers <map_id>     - List all layers in a map");
    println!("  map <map_id>             - Show map information");
    println!("  layers <map_id>          - List layers in a map (same as 'list layers')");
    println!("  tile <layer_id> <x> <y>  - Get tile at position (x, y) in layer");
    println!("  objects <layer_id>       - List all objects in a layer");
    println!("  spawns                   - Find all spawn points");
    println!("  props <type> <id>        - Show properties (type: map, layer, object, etc.)");
    println!("  walkable <x> <y>         - Check if position is walkable (checks layer 1)");
    println!("  quit                     - Exit the client");
    println!();
}

/// Handle 'list' command
fn handle_list(conn: &DbConnection, args: &[&str]) {
    if args.is_empty() {
        println!("Usage: list <maps|layers|tilesets>");
        return;
    }

    match args[0] {
        "maps" => {
            let maps = conn.db.tiled_map().iter().collect::<Vec<_>>();
            if maps.is_empty() {
                println!("No maps loaded.");
            } else {
                println!("\nLoaded Maps:");
                for map in maps {
                    println!(
                        "  [{}] '{}' - {}x{} tiles ({}x{} px)",
                        map.map_id,
                        map.name,
                        map.width,
                        map.height,
                        map.tile_width,
                        map.tile_height
                    );
                    println!("      Orientation: {}", map.orientation);
                }
                println!();
            }
        }
        "layers" => {
            if args.len() < 2 {
                println!("Usage: list layers <map_id>");
                return;
            }
            if args[1].parse::<u32>().is_ok() {
                handle_layers(conn, &[args[1]]);
            } else {
                println!("Invalid map_id: {}", args[1]);
            }
        }
        "tilesets" => {
            let tilesets = conn.db.tiled_tileset().iter().collect::<Vec<_>>();
            if tilesets.is_empty() {
                println!("No tilesets found.");
            } else {
                println!("\nTilesets:");
                for ts in tilesets {
                    println!("  [{}] '{}' (map {})", ts.tileset_id, ts.name, ts.map_id);
                    println!(
                        "      Index: {}, Tiles: {}, Size: {}x{} px",
                        ts.tileset_index, ts.tile_count, ts.tile_width, ts.tile_height
                    );
                    if let Some(ref img) = ts.image_source {
                        println!("      Image: {}", img);
                    }
                }
                println!();
            }
        }
        _ => println!(
            "Unknown list target: '{}'. Use 'maps', 'layers', or 'tilesets'.",
            args[0]
        ),
    }
}

/// Handle 'tile' command
fn handle_tile(conn: &DbConnection, args: &[&str]) {
    if args.len() < 3 {
        println!("Usage: tile <layer_id> <x> <y>");
        return;
    }

    let layer_id = args[0].parse::<u32>();
    let x = args[1].parse::<u32>();
    let y = args[2].parse::<u32>();

    match (layer_id, x, y) {
        (Ok(lid), Ok(tx), Ok(ty)) => {
            let tile = conn
                .db
                .tiled_tile()
                .iter()
                .find(|t| t.layer_id == lid && t.x == tx && t.y == ty);

            match tile {
                Some(t) => {
                    println!("\nTile at ({}, {}) in layer {}:", tx, ty, lid);
                    println!("  GID: {}", t.gid);
                    println!("  Flipped: H={}, V={}, D={}", t.flip_h, t.flip_v, t.flip_d);

                    // Find tileset
                    let tilesets = conn.db.tiled_tileset().iter().collect::<Vec<_>>();
                    for ts in tilesets {
                        println!("  Tileset: '{}' (index={})", ts.name, ts.tileset_index);
                        break;
                    }
                    println!();
                }
                None => println!("No tile at ({}, {}) in layer {}.", tx, ty, lid),
            }
        }
        _ => println!("Invalid arguments. Use numeric values for layer_id, x, and y."),
    }
}

/// Handle 'objects' command
fn handle_objects(conn: &DbConnection, args: &[&str]) {
    if args.is_empty() {
        println!("Usage: objects <layer_id>");
        return;
    }

    if let Ok(layer_id) = args[0].parse::<u32>() {
        let objects: Vec<_> = conn
            .db
            .tiled_object()
            .iter()
            .filter(|o| o.layer_id == layer_id)
            .collect();

        if objects.is_empty() {
            println!("No objects in layer {}.", layer_id);
        } else {
            println!("\nObjects in layer {}:", layer_id);
            for obj in objects {
                println!("  [{}] '{}' ({})", obj.object_id, obj.name, obj.obj_type);
                println!("      Position: ({:.1}, {:.1})", obj.x, obj.y);
                println!("      Size: {:.1}x{:.1}", obj.width, obj.height);
                if obj.rotation != 0.0 {
                    println!("      Rotation: {:.1}°", obj.rotation);
                }
                println!("      Shape: {}, Visible: {}", obj.shape, obj.visible);
            }
            println!();
        }
    } else {
        println!("Invalid layer_id: {}", args[0]);
    }
}

/// Handle 'spawns' command
fn handle_spawns(conn: &DbConnection) {
    let spawns: Vec<_> = conn
        .db
        .tiled_object()
        .iter()
        .filter(|o| o.obj_type == "spawn")
        .collect();

    if spawns.is_empty() {
        println!("No spawn points found.");
    } else {
        println!("\nSpawn Points:");
        for spawn in spawns {
            println!("  '{}' at ({:.1}, {:.1})", spawn.name, spawn.x, spawn.y);

            // Show properties
            let props: Vec<_> = conn
                .db
                .tiled_property()
                .iter()
                .filter(|p| p.parent_type == "object" && p.parent_id == spawn.object_id)
                .collect();

            for prop in props {
                println!("    {} = {} ({})", prop.key, prop.value, prop.value_type);
            }
        }
        println!();
    }
}

/// Handle 'map' command
fn handle_map_info(conn: &DbConnection, args: &[&str]) {
    if args.is_empty() {
        println!("Usage: map <map_id>");
        return;
    }

    if let Ok(map_id) = args[0].parse::<u32>() {
        let map = conn.db.tiled_map().iter().find(|m| m.map_id == map_id);

        match map {
            Some(m) => {
                println!("\nMap [{}]: '{}'", m.map_id, m.name);
                println!("  Size: {}x{} tiles", m.width, m.height);
                println!("  Tile Size: {}x{} pixels", m.tile_width, m.tile_height);
                println!("  Orientation: {}", m.orientation);
                if let Some(ref bg) = m.background_color {
                    println!("  Background: {}", bg);
                }

                // Count layers
                let layer_count = conn
                    .db
                    .tiled_layer()
                    .iter()
                    .filter(|l| l.map_id == map_id)
                    .count();
                println!("  Layers: {}", layer_count);

                // Count tilesets
                let tileset_count = conn
                    .db
                    .tiled_tileset()
                    .iter()
                    .filter(|t| t.map_id == map_id)
                    .count();
                println!("  Tilesets: {}", tileset_count);

                println!();
            }
            None => println!("Map {} not found.", map_id),
        }
    } else {
        println!("Invalid map_id: {}", args[0]);
    }
}

/// Handle 'layers' command
fn handle_layers(conn: &DbConnection, args: &[&str]) {
    if args.is_empty() {
        println!("Usage: layers <map_id>");
        return;
    }

    if let Ok(map_id) = args[0].parse::<u32>() {
        let mut layers: Vec<_> = conn
            .db
            .tiled_layer()
            .iter()
            .filter(|l| l.map_id == map_id)
            .collect();

        if layers.is_empty() {
            println!("No layers found in map {}.", map_id);
        } else {
            layers.sort_by_key(|l| l.z_order);

            println!("\nLayers in map {}:", map_id);
            for layer in layers {
                println!(
                    "  [{}] '{}' ({})",
                    layer.layer_id, layer.name, layer.layer_type
                );
                println!(
                    "      Visible: {}, Opacity: {}",
                    layer.visible, layer.opacity
                );
                println!(
                    "      Offset: ({}, {}), Z-order: {}",
                    layer.offset_x, layer.offset_y, layer.z_order
                );

                // Count contents
                match layer.layer_type.as_str() {
                    "tile" => {
                        let count = conn
                            .db
                            .tiled_tile()
                            .iter()
                            .filter(|t| t.layer_id == layer.layer_id)
                            .count();
                        println!("      Contains {} tiles", count);
                    }
                    "object" => {
                        let count = conn
                            .db
                            .tiled_object()
                            .iter()
                            .filter(|o| o.layer_id == layer.layer_id)
                            .count();
                        println!("      Contains {} objects", count);
                    }
                    _ => {}
                }
            }
            println!();
        }
    } else {
        println!("Invalid map_id: {}", args[0]);
    }
}

/// Handle 'props' command
fn handle_properties(conn: &DbConnection, args: &[&str]) {
    if args.len() < 2 {
        println!("Usage: props <type> <id>");
        println!("  Types: map, layer, tile, object, tileset");
        return;
    }

    let parent_type = args[0];
    if let Ok(parent_id) = args[1].parse::<u64>() {
        let props: Vec<_> = conn
            .db
            .tiled_property()
            .iter()
            .filter(|p| p.parent_type == parent_type && p.parent_id == parent_id)
            .collect();

        if props.is_empty() {
            println!("No properties found for {} {}.", parent_type, parent_id);
        } else {
            println!("\nProperties for {} {}:", parent_type, parent_id);
            for prop in props {
                println!("  {} = {} ({})", prop.key, prop.value, prop.value_type);
            }
            println!();
        }
    } else {
        println!("Invalid id: {}", args[1]);
    }
}

/// Handle 'walkable' command
fn handle_walkable(conn: &DbConnection, args: &[&str]) {
    if args.len() < 2 {
        println!("Usage: walkable <x> <y>");
        return;
    }

    let x = args[0].parse::<u32>();
    let y = args[1].parse::<u32>();

    match (x, y) {
        (Ok(tx), Ok(ty)) => {
            // Check collision layer (layer 1)
            let collision_layer_id = 1u32;

            let tile = conn
                .db
                .tiled_tile()
                .iter()
                .find(|t| t.layer_id == collision_layer_id && t.x == tx && t.y == ty);

            let walkable = match tile {
                Some(t) if t.gid == 0 => true,
                Some(_) => false,
                None => true,
            };

            println!(
                "Position ({}, {}) is {}.",
                tx,
                ty,
                if walkable { "walkable" } else { "blocked" }
            );
        }
        _ => println!("Invalid coordinates. Use numeric values."),
    }
}
